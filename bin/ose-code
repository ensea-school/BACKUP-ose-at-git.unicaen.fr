#!/usr/bin/env php
<?php

use Laminas\Cli\ApplicationFactory;
use Laminas\Cli\ApplicationProvisioner;
use Laminas\Cli\ContainerResolver;
use Symfony\Component\Console\Input\ArgvInput;
use Symfony\Component\Console\Output\ConsoleOutput;

require dirname(__DIR__) . '/admin/src/start.php';

$args   = $_SERVER['argv'];
$script = $args[0];
unset($args[0]);
$args = array_merge([$script, 'unicaen-code:run'], $args);

$_SERVER['argv'] = $args;

$app                      = (new ApplicationFactory())();
$definition               = $app->getDefinition();
$output                   = new ConsoleOutput();
$containerNotFoundMessage = '';
$input                    = new ArgvInput($args);

set_error_handler(function ($errno, $errstr, $errfile, $errline) use ($output) {
    $output->writeln("<error>Erreur : $errstr</error>");
    echo "Dans le fichier : $errfile à la ligne : $errline\n\n";

    if (OseAdmin::instance()->env()->inDev()) {
        echo "Trace d'exécution :\n";
        $trace = debug_backtrace();
        foreach ($trace as $index => $info) {
            echo "#{$index} {$info['file']} ({$info['line']}): ";
            echo isset($info['class']) ? "{$info['class']}::" : '';
            echo "{$info['function']}()\n";
        }
        echo "\n";
    }
});

try {
    $input->bind($definition);
} catch (\Symfony\Component\Console\Exception\RuntimeException $exception) {
    // Ignore validation issues as we did not yet have the commands definition
    // As we only need the `--container` option, we are good to go until it is passed *before* the first command argument
    // Symfony parses the `argv` in its direct order and raises an error when more arguments or options are passed
    // than described by the default definition.
}

try {
    $container = (new ContainerResolver(getcwd()))->resolve($input);
    $app       = (new ApplicationProvisioner())($app, $container);
} catch (RuntimeException|InvalidArgumentException $exception) {
    // Usage information provided by the `ContainerResolver` should be passed to the CLI output
    $containerNotFoundMessage = sprintf('<error>%s</error>', $exception->getMessage());
}

// By running the app even if its not provisioned allows symfony/console to report problems
// and/or display available options (like `--container`)
$exitCode = $app->run(null, $output);

if ($containerNotFoundMessage) {
    $output->writeln($containerNotFoundMessage);
    $exitCode = 255;
}

exit($exitCode);