#!/usr/bin/env php
<?php

/* --------------- Début des paramétrages --------------- */

// Titre...
$title = 'Installation de OSE';

// Version minimale proposée, pour ne pas afficher de vieilles versions, 0 si pas de minimum
$minVersion = 20;

// Fichier spécifiant la version installée dans le code source du projet (chemin relatif)
// Si null, pas de version enregistrée
$versionFile = 'VERSION';

// URL du dépôt Git
$gitRepoUrl = 'https://git.unicaen.fr/open-source/OSE.git';

// Si le projet n'a pas de fichier de configuration global => on passe à false
$hasConfigFile = true;

// Fichier de configuration par défaut dans le code source du projet (chemin relatif)
// Utile uniquement si $hasConfigFile = true
$defaultConfigFile = 'config.local.php.default';

// Nom du fichier de configuration dans le code source du projet (chemin relatif)
// Utile uniquement si $hasConfigFile = true
$configFileName = 'config.local.php';

// Doit s'occuper d'installer composer ou pas (bool)
$composerInstall = true;

// Commande pour exécuter composer
$composerCommand = 'composer';

// Répertoire de cache de l'application (chemin relatif)
$cacheDir = 'cache';

// Commande à lancer après l'installation de l'application
$postInstallFnc = function (Console $c, string $dir) {
    $piFile = $dir . "/vendor/bin/laminas";
    if (file_exists($piFile)) {
        $c->passthru(["cd $dir", "./vendor/bin/laminas install"]);
    } else {
        $c->writeln("\nGénération des proxies pour l'ORM Doctrine", $c::COLOR_LIGHT_CYAN);
        $c->exec(["cd $dir", "php bin/ose clear-cache"]);

        $c->writeln("\nFin du script d'installation des fichiers", $c::COLOR_LIGHT_GREEN);
        $c->writeln("Il reste encore plusieurs étapes à réaliser pour que OSE soit pleinement fonctionnel :");
        $c->writeln(" 1 - Configurez votre serveur Apache si ce n'est déjà fait");
        $c->writeln(" 2 - Veuillez personnaliser le fichier de configuration de OSE config.local.php, si ce n'est déjà le cas");
        $c->writeln(" 3 - La base de données devra au besoin être initialisée à l'aide de la commande ./bin/ose install-bdd. Si votre base était déjà initialisée, alors la commande ./bin/ose update-bdd sera privilégiée");
        $c->writeln(" 4 - Mettez en place les tâches CRON nécessaires (envoi de mails pour les indicateurs, Synchronisation automatique, etc.");
        $c->writeln('');
        $c->writeln("Pour la suite, merci de vous reporter au guide de l'administrateur pour vous aider à configurer l'application");
        $c->writeln('');
    }
};

// Liste des commandes systèmes qui doivent être installées
$depCommands = [
    'git'     => 'Gestionnaire de versions',
    'php'     => 'Langage PHP',
    'wget'    => 'Téléchargement en ligne de commande',
    'unoconv' => ['description' => 'Convertisseur OpenDocument vers PDF', 'facultatif' => false],
];

// Liste des modules PHP qui doivent être installés
$depModules = [
    'curl'         => 'Curl',
    'intl'         => 'Intl',
    'json'         => 'Json',
    'ldap'         => 'Ldap',
    'mbstring'     => 'MbString',
    'Zend OPcache' => 'Zend OPcache',
    'xml'          => 'XML',
    'zip'          => 'ZIP',
    'bcmath'       => 'BCMath',
    'gd'           => 'GD',
    'oci8'         => 'OCI8 (Pilote Oracle)',
];


/* --------------- Initialisation --------------- */

unlink(__FILE__);

$c = new Console();

$repo = new GitRepoService();
$repo->setMinVersion($minVersion);
$repo->setUrl($gitRepoUrl);


/* ---------- Récup & contrôle des paramètres en entrée --------- */

$inputOptions = [
    'no-check',
    'no-title',
    'no-composer-install',
    'version:',
    'dir:',
    'config-file:',
];
$c->setInputOptions($inputOptions);


// Affichage du titre
if (!$c->getOption('no-title')) {
    $c->title($title, 13);
}


// Contrôle des dépendances
if (!$c->getOption('no-check')) {
    $controle = new AppControle($c);
    $controle->checkCommands($depCommands);
    $controle->checkPhpModules($depModules);
}

if (!$repo->gitlabIsReachable()) {
    $c->error("Le dépôt \"$gitRepoUrl\" de l'application est inaccessible.");
}


// Choix de la version
$version = $c->getOption('version');
if (!$version) {
    $c->section("\nSélection de la version à déployer");
    $c->writeln("Voici la liste des versions disponibles:");
    $tags = $repo->getTags();
    foreach ($tags as $tag) {
        $c->writeln('  ' . $tag['tag']);
    }
    $c->write("Veuillez choisir une version à déployer: ");
    $version = $c->getInput('version');
}

if ($repo->tagIsValid($version)) {
    $isTag     = true;
    $isBranche = false;
} elseif ($repo->brancheIsValid($version)) {
    $isTag     = false;
    $isBranche = true;
} else {
    $c->error('La version ou la branche ' . $version . ' est invalide');
}


// Détermination du répertoire d'installation
$dir = $c->getOption('dir');
if (null === $dir) {
    $c->write("Veuillez indiquer un nouveau répertoire où implanter OSE: ");
    $dir = $c->getInput('ose-dir');
}
$dir = $c->absolutePath($dir, __DIR__);
if (file_exists($dir)) {
    $c->error("Le répertoire $dir existe déjà. Merci de le supprimer ou d'en spécifier un nouveau.");
}


// Si config-file est fourni, test de l'existence du fichier
if ($hasConfigFile) {
    $configFile = $c->getOption('config-file');
    if ($configFile) {
        $configFile = $c->absoluteFilename($configFile, __DIR__);
        if (!file_exists($configFile) || !is_file($configFile)) {
            $c->error('Le fichier de configuration "' . $configFile . '" transmis est inexistant ou n\'est pas un fichier');
        }
    } else {
        $configFile = $dir . $defaultConfigFile;
    }
} else {
    $configFile = null;
}

// Paramétrages pour composer
if ($c->getOption('no-composer-install')) {
    $composerInstall = false;
}


/* --------------- Début de l'installation --------------- */

$bt = $isTag ? 'version' : 'branche';
$c->section('Début de l\'installation de la ' . $bt . ' ' . $version);
$c->section('Rapatriement du dépot GIT');
$tbr  = $isTag ? 'tags/' : '';
$cmds = [
    "mkdir $dir",
    "cd $dir",
    "git init",
    "git remote add origin " . $gitRepoUrl,
    "git fetch --all --tags --prune > /dev/null 2>&1",
    "git checkout $tbr$version",
];
$c->exec($cmds);


// Ecriture de la version dans le fichier
if ($versionFile) {
    $repo->setVersionFile($dir . $versionFile);
    $repo->writeVersion($version);
}


// Mise en place du fichier de configuration
if ($hasConfigFile && $configFile) {
    $c->section('Mise en place du fichier de configuration');
    copy($configFile, $dir . $configFileName);
}


// Préparation du dossier de cache
if ($cacheDir) {
    $c->section('Mise en place du cache');
    if (!file_exists($dir . $cacheDir)) {
        mkdir($dir . $cacheDir);
    }
    chmod($dir . $cacheDir, 0777);
}


// Installation de Composer
if ($composerInstall) {
    $c->section('Installation de Composer pour la gestion des dépendances');
    $composerSetupFile = 'composer-setup.php';
    $c->passthru("cd $dir;wget https://getcomposer.org/installer; mv installer $composerSetupFile");
    if (!hash_file('sha384', $dir . $composerSetupFile) === '55ce33d7678c5a611085589f1f3ddf8b3c52d662cd01d4ba75c0ee0459970c2200a51f492d557530c71c15d8dba01eae') {
        die('Installeur de composer corrompu');
        unlink($dir . $composerSetupFile);
    }
    $c->passthru("cd $dir;php $composerSetupFile");
    unlink($dir . $composerSetupFile);
    $composerCommand = 'php ' . $dir . 'composer.phar';
}


// Chargement des dépendances à l'aide de Composer
$c->section('Chargement des dépendances à l\'aide de Composer');
$c->passthru("cd $dir;COMPOSER_ALLOW_SUPERUSER=1 $composerCommand install --optimize-autoloader");


// Poursuite de la procédure d'installation en passant la main
$postInstallFnc($c, $dir);


/************************************************************
 *                      Classes utiles                      *
 ************************************************************/
class AppControle
{
    /**
     * @var Console
     */
    protected $console;



    /**
     * AppControle constructor.
     *
     * @param Console $console
     */
    public function __construct(Console $console)
    {
        $this->console = $console;
    }



    public function checkCommands(array $prerequis): bool
    {
        if (empty($prerequis)) {
            return true;
        }

        $len = 60;
        $res = true;

        $this->console->section("Contrôle des prérequis à l'exécution du script");
        $this->console->writeln($this->console->strPad('Commande (description éventuelle)', $len) . "Résultat");
        $this->console->writeln($this->console->strPad('----------------------', $len) . "--------");
        foreach ($prerequis as $command => $desc) {
            if (is_array($desc)) {
                extract($desc);
            } else {
                $description = $desc;
                $facultatif  = false;
            }

            $return = null;
            exec('command -v ' . $command, $null, $result);
            $passed = ($result == 0);

            $this->console->write($this->console->strPad($command . ($description ? " ($description)" : ''), $len));
            if ($passed) {
                $this->console->write('Commande trouvée' . "\n", $this->console::COLOR_LIGHT_GREEN);
            } elseif ($facultatif) {
                $this->console->write('Manquante, facultative' . "\n", $this->console::COLOR_LIGHT_PURPLE);
            } else {
                $this->console->write('Commande manquante' . "\n", $this->console::COLOR_LIGHT_RED);
                $res = false;
            }
        }

        if (!$res) {
            $this->console->error('Un ou plusieurs prérequis nécessaires ne sont pas présents sur cette machine. Merci de les installer avant de poursuivre l\'installation.');
        }

        return $res;
    }



    public function checkPhpModules(array $modules): bool
    {
        if (empty($modules)) {
            return true;
        }

        $len    = 60;
        $result = true;

        $this->console->section("Contrôle d'existance des modules PHP nécessaires");
        $this->console->writeln($this->console->strPad('Module PHP', $len) . "Résultat");
        $this->console->writeln($this->console->strPad('----------', $len) . "--------");
        foreach ($modules as $module => $description) {
            $return = null;
            $passed = in_array($module, get_loaded_extensions());

            $this->console->write($this->console->strPad($description, $len));
            if ($passed) {
                $this->console->write('Module trouvé' . "\n", $this->console::COLOR_LIGHT_GREEN);
            } else {
                $this->console->write('Module manquant' . "\n", $this->console::COLOR_LIGHT_RED);
            }

            if (!$passed) $result = false;
        }

        if (!$result) {
            $this->console->error('Un ou plusieurs modules PHP sont manquants. Merci de les installer pour poursuivre l\'installation de OSE');
        }

        return $result;
    }

}


class Console
{
    const COLOR_BLACK        = '0;30';
    const COLOR_DARK_GRAY    = '1;30';
    const COLOR_BLUE         = '0;34';
    const COLOR_LIGHT_BLUE   = '1;34';
    const COLOR_GREEN        = '0;32';
    const COLOR_LIGHT_GREEN  = '1;32';
    const COLOR_CYAN         = '0;36';
    const COLOR_LIGHT_CYAN   = '1;36';
    const COLOR_RED          = '0;31';
    const COLOR_LIGHT_RED    = '1;31';
    const COLOR_PURPLE       = '0;35';
    const COLOR_LIGHT_PURPLE = '1;35';
    const COLOR_BROWN        = '0;33';
    const COLOR_YELLOW       = '1;33';
    const COLOR_LIGHT_GRAY   = '0;37';
    const COLOR_WHITE        = '1;37';

    const BG_BLACK      = '40';
    const BG_RED        = '41';
    const BG_GREEN      = '42';
    const BG_YELLOW     = '43';
    const BG_BLUE       = '44';
    const BG_MAGENTA    = '45';
    const BG_CYAN       = '46';
    const BG_LIGHT_GRAY = '47';

    /**
     * @var array
     */
    protected $inputOptions = false;

    /**
     * @var array
     */
    protected $options = false;



    public function title($title, $spaces = 1): void
    {
        $pstr = str_repeat(' ', $spaces);
        $t    = $pstr . $title . $pstr;

        $len = strlen($t);

        echo '╔' . str_repeat('═', $len) . "╗\n";
        echo '║' . str_repeat(' ', $len) . "║\n";
        echo "║" . $t . "║\n";
        echo '║' . str_repeat(' ', $len) . "║\n";
        echo '╚' . str_repeat('═', $len) . "╝\n\n";
    }



    public function write(string $text, string $color = null, string $bgColor = null): void
    {
        if ($bgColor) $bgColor = ';' . $bgColor;

        if (!$color && !$bgColor) {
            echo $text;
        } else {
            echo "\e[$color$bgColor" . "m$text\e[0m";
        }
    }



    public function section(string $text): void
    {
        $this->write($text . "\n", self::COLOR_LIGHT_CYAN);
    }



    public function writeln(string $text): void
    {
        $this->write($text . "\n");
    }



    private function gestExitCode($code): void
    {
        if (0 == $code) return;

        $this->error("Une erreur ($code) est survenue. Le script est stoppé");
    }



    public function error($text): void
    {
        $this->write($text . "\n", self::COLOR_LIGHT_RED);
        $this->write(' -- FIN Prématurée de l\'exécution du script -- ' . "\n", null, self::BG_RED);
        die("\n");
    }



    /**
     * @return array
     */
    public function getInputOptions(): array
    {
        return $this->inputOptions;
    }



    /**
     * @param array $inputOptions
     */
    public function setInputOptions(array $inputOptions): void
    {
        $this->inputOptions = $inputOptions;
    }



    public function getOption(string $option): mixed
    {
        if (!is_array($this->options)) {
            if (is_array($this->inputOptions)) {
                $this->options = getopt('', $this->inputOptions);
            } else {
                return null;
            }
        }

        if (isset($this->options[$option])) {
            if (false === $this->options[$option]) {
                return true;
            } else {
                return $this->options[$option];
            }
        } else {
            return null;
        }
    }



    public function getInput($option = null): mixed
    {
        if ($option) {
            $optionParam = $this->getOption($option);
            if (null !== $optionParam) {
                $this->writeln($optionParam);

                return $optionParam;
            }
        }

        return trim(fgets(STDIN));
    }



    public function exec(string|array $command, bool $autoDisplay = true): mixed
    {
        if (is_array($command)) {
            $command = implode(';', $command);
        }

        exec($command, $output, $return);
        if ($autoDisplay) {
            echo implode("\n", $output) . "\n";
        }
        $this->gestExitCode($return);

        return $output;
    }



    public function passthru(string|array $command): mixed
    {
        if (is_array($command)) {
            $command = implode(';', $command);
        }

        passthru($command, $returnVar);
        $this->gestExitCode($returnVar);

        return $returnVar;
    }



    public function strPad(string $input, ?int $padLength = null, string $padString = ' ', string $align = STR_PAD_LEFT): string
    {
        $strLen = mb_strlen($input);
        if ($strLen >= $padLength) {
            return $input;
        }

        $diff    = $padLength - $strLen;
        $padding = mb_substr(str_repeat($padString, $diff), 0, $diff);

        switch ($align) {
            case STR_PAD_BOTH:
                $diffHalf = (int)($diff / 2 + 0.5);
                $padding  = str_repeat($padString, $diffHalf);
                $result   = "{$padding}{$input}{$padding}";
                break;
            case STR_PAD_LEFT:
                $result = "{$padding}{$input}";
                $result = "{$input}{$padding}";
                break;
            case STR_PAD_RIGHT:
            default:
                $result = "{$input}{$padding}";
                break;
        }

        return \mb_substr($result, 0, $padLength);
    }



    public function absolutePath(string $path, string $refDir = __DIR__): string
    {
        $path = $this->absoluteFilename($path, $refDir);
        if (!str_ends_with($path, '/')) {
            $path .= '/';
        }

        return $path;
    }



    public function absoluteFilename(string $filename, string $refDir = __DIR__): string
    {
        if (!str_starts_with($filename, '/')) {
            $filename = $refDir . '/' . $filename;
        }
        while (false !== strpos($filename, '..')) {
            // Sépare les parties du chemin
            $parts     = array_filter(explode('/', $filename), 'strlen');
            $absolutes = [];

            foreach ($parts as $part) {
                if ($part == '.') continue;
                if ($part == '..') {
                    array_pop($absolutes);
                } else {
                    $absolutes[] = $part;
                }
            }
            $filename = '/' . implode('/', $absolutes);
        }

        return $filename;
    }
}


class GitRepoService
{
    private array|bool $tags        = false;
    private array|bool $branches    = false;
    protected string   $oldVersion;
    protected string   $version;
    protected string   $url;
    protected string   $versionFile = 'VERSION';
    protected int      $minVersion  = 0;



    public function __construct()
    {
        $this->oldVersion = $this->currentVersion();
    }



    public function getMinVersion(): int
    {
        return $this->minVersion;
    }



    public function setMinVersion(int $minVersion): GitRepoService
    {
        $this->minVersion = $minVersion;
        return $this;
    }



    public function getUrl(): string
    {
        return $this->url;
    }



    public function setUrl(string $url): GitRepoService
    {
        $this->url = $url;
        return $this;
    }



    public function getVersionFile(): string
    {
        return $this->versionFile;
    }



    public function setVersionFile(string $versionFile): GitRepoService
    {
        $this->versionFile = $versionFile;
        return $this;
    }



    private function exec(string|array $command, bool $autoDisplay = true)
    {
        if (is_array($command)) {
            $command = implode(';', $command);
        }

        exec($command, $output, $return);
        if ($autoDisplay) {
            echo implode("\n", $output) . "\n";
        }
        //$this->gestExitCode($return);

        return $output;
    }



    public function gitlabIsReachable(): bool
    {
        return $this->brancheIsValid('master');
    }



    public function getTags(): array
    {
        if (false === $this->tags) {
            $this->tags = [];

            $ts = $this->exec("git ls-remote --tags --refs " . $this->getUrl(), false);
            foreach ($ts as $tag) {
                $tag              = substr($tag, strpos($tag, 'refs/tags/') + 10);
                $this->tags[$tag] = $this->extractTagInfos($tag);
            }

            uasort($this->tags, function ($a, $b) {
                $oa = $this->tagOrderString($a);
                $ob = $this->tagOrderString($b);

                return $oa > $ob ? 1 : -1;
            });
        }

        $tags = $this->tags;

        foreach ($tags as $tag => $infos) {
            if ($infos['major'] < $this->getMinVersion()) unset($tags[$tag]);
            if (isset($tags[$tag]) && $infos['beta']) {
                $stableFound = false;
                foreach ($this->tags as $t => $i) {
                    if ($t !== $tag && !$i['beta']) {
                        if (str_starts_with($tag, $t)) {
                            $stableFound = true;
                        }
                    }
                }
                if ($stableFound) {
                    unset($tags[$tag]);
                }
            }
        }

        return $tags;
    }



    public function getBranches(): array
    {
        if (false === $this->branches) {
            $this->branches = [];

            $bs = $this->exec("git ls-remote --heads --refs " . $this->getUrl(), false);
            foreach ($bs as $branche) {
                $this->branches[] = substr($branche, strpos($branche, 'refs/heads/') + 11);
            }

            sort($this->branches);
        }

        return $this->branches;
    }



    public function getCurrentBranche(): ?string
    {
        $ts = $this->exec("git branch", false);
        foreach ($ts as $t) {
            if (0 === strpos($t, '*')) {
                return trim(substr($t, 1));
            }
        }

        return null;
    }



    public function tagIsValid(string $tag): bool
    {
        $tags = $this->getTags();
        foreach ($tags as $t) {
            if ($t['tag'] == $tag) {
                return true;
            }
        }
        return false;
    }



    public function brancheIsValid(string $branche): bool
    {
        return in_array($branche, $this->getBranches());
    }



    public function oldVersion(): string
    {
        return $this->oldVersion;
    }



    public function currentVersion(): string
    {
        if (!file_exists($this->getVersionFile())) {
            return 'inconnue';
        }

        return trim(file_get_contents($this->getVersionFile()));
    }



    public function writeVersion(string $version)
    {
        $this->version = $version;
        file_put_contents($this->getVersionFile(), $version);
    }



    protected function extractTagInfos(string $tag): array
    {
        $i = [
            'tag'     => $tag,
            'major'   => 0,
            'minor'   => 0,
            'rev'     => 0,
            'beta'    => false,
            'betaNum' => null,
            'other'   => null,
        ];

        if ((string)(int)$tag === $tag) {
            // uniquement une version majeure
            $i['major'] = (int)$tag;
            return $i;
        }


        if (false !== strpos($tag, '-')) {
            $txt = substr($tag, strpos($tag, '-') + 1);

            if (str_starts_with(strtolower($txt), 'beta')) {
                $btxt = substr($txt, 4);

                if ($btxt === '') {
                    $i['beta']    = true;
                    $i['betaNum'] = 0;
                } elseif ((int)$btxt != 0) {
                    $i['beta']    = true;
                    $i['betaNum'] = (int)$btxt;
                } else {
                    $i['other'] = $txt;
                }
            } else {
                $i['other'] = $txt;
            }

            // ne reste que le numéro de version
            $tag = substr($tag, 0, strpos($tag, '-'));
        }

        $nums = explode('.', $tag);

        if (isset($nums[0])) {
            $i['major'] = (int)$nums[0];
        }
        if (isset($nums[1])) {
            $i['minor'] = (int)$nums[1];
        }
        if (isset($nums[2])) {
            $i['rev'] = (int)$nums[2];
        }

        return $i;
    }



    protected function tagOrderString(array $infos): string
    {
        return str_pad((string)$infos['major'], 5, '0', STR_PAD_LEFT)
            . 'x' . str_pad((string)$infos['minor'], 5, '0', STR_PAD_LEFT)
            . 'x' . str_pad((string)$infos['rev'], 5, '0', STR_PAD_LEFT)
            . 'x' . ($infos['beta'] ? '0' : '1')
            . 'x' . str_pad((string)$infos['betaNum'], 5, '0', STR_PAD_LEFT)
            . 'x' . $infos['other'];
    }
}